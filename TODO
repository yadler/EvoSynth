Aus Weickers Buch (noch) nicht implementiert:

Mutationen:
	- SELBSTADAPTIVE-GAUSS-MUTATION (Weicker page 114
		-> hier ist zu klären wie S1 pro individuum gespeichert wird?!
			- metaprogramming: mutation fügt das einfach hinzu
							oder
			- individuen müssen das der mutation zur verfügung stellen

Algorithmen:
	- reichlich grob formuliert:  EA-SCHEMA (Weicker page 39)
	- eher als beispiel geeignet: EA-HANDLUNGSREISENDENPROBLEM (Weicker page 31)

Benchmarkfunktionen:
	- Einsenzählproblem (Seite 272)
	- Royal-Road (Seite 272)
	- C-Funktion (Seite 272)
	- sämtliche mit Randbedingungen (Seite 274)

------------------------------------------------

Was ist mit Benchmarkfunktionen?! (SPk und co)

------------------------------------------------

was ist mit pheno/genetyp? reichen decoder oder sollte explizite unterscheidung gemacht werden?

------------------------------------------------

evobench (mutationen, selektionen und co)

------------------------------------------------

diversität und zeugs

-----------------------------------------------

für mockups:

http://flexmock.rubyforge.org/
http://mocha.rubyforge.org/
http://github.com/notahat/machinist

-----------------------------------------------

DSL erstellen?

evolution do
	population is
		Population.new(foo)
	end
	mutation is
		bar
	end
end

